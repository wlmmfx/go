##  笔记记录
####  控制器
+   命名规范遵循PSR-2规范，并且约定了以下规则：  
    +   1、目录名统一使用小写+下划线，eg：`linux_shell/`    
    +   2、类名使用驼峰（首字母大写）命名，eg:`LinuxShell.php`     
    +   3、类的方法使用驼峰（首字母小写）命名，eg：`saveInfo()`     
    +   4、特别强调：模块名作为目录作用强制使用小写和下划线规范  
+   PSR-4的规范
    +   1、模块名作为目录作用强制使用小写和下划线规范
    +   2、子命名空间和目录**必须**是一一对应的，而且**大小写一致**
    +   3、**类的组成 = 根命名空间+子命名空间（可选）+类名**
    +   4、完整命名空间实例化的时候必须加上开头的\表示从根命名空间开始  
        > `$controller = new \app\admin\controller\Index();`     
    +   5、核心类库都是以think开头的命名空间，应用类库都是以app开头的命名空间
+   操作方法
    +   控制器类的每一个public类型方法（包括继承的）都是一个可访问的操作，也是URL访问的最小单元      
    +   `private`和`protected`类型的方法都不能被访问（只能在控制器内部被调用） 
    +   `ThinkPHP5`的操作方法建议统一使用`return`返回值的方式进行响应输出,优势是系统可以自动判断当前的响应输出类型进行自动转换处理，以及可以享受请求缓存的便利。     
+   驼峰命名
    +   控制器类名的规范是驼峰法（并且首字母大写）
    +   注意hello_world并不会自动对应hello_world控制器（因为不符合控制器类的命名规范），仍然会自动对应HelloWorld控制器类。
    +   这一切因果缘由就是框架的URL自动转换功能，由于系统的URL自动转换功能，ThinkPHP5的URL地址默认是不区分大小写的（也就是说都会强制转换成小写）
+   控制器后缀
    +   为什么会有控制器后缀的概念呢？
        +   首先是如果控制器类不带后缀，容易产生和关键字冲突的情况，例如无法使用public控制器
        +   其次，控制器类和模型类容易产生混淆，例如User控制器类和User模型类，默认不使用控制器后缀
    +   注意：开启了控制器类后缀的话，类名和类文件名依然要保持大小写一致
    +   **总结：没必要开启**
+   方法后缀
    +   为了避免操作方法名和关键字混淆，我们也可以给操作方法统一添加方法后缀，例如设置操作方法后缀为Action
        
        ```php
        // 设置操作方法后缀
        'action_suffix'	=>	'Action',
        ```
+   多级控制器
    +   **强力推荐使用**
    +   控制器分组和分级的管理需求
    +   开启控制器自动搜索定位：`'controller_auto_search' => true,`   
+   资源控制器
    +   资源控制器可以让你轻松的创建RESTFul资源控制器，可以通过命令行生成需要的资源控制器
    +   生成index模块的Blog资源控制器：`php think make:controller index/Blog`
+   使用`trait`
    +   `trait`是一种为类似 PHP 的单继承语言而准备的代码复用机制    
    +   `trait`和类组合的语义是定义了一种方式来减少复杂性，避免传统多继承和混入类（Mixin）相关的典型问题   
    +   注意：如果你没有继承系统的控制器基类，但是又希望能使用think\Controller控制器基类的一些方法，可以引入trait   
    +   引入trait的方式用的也是use语法，但和引入类完全不同，**建议规范是在类的主体代码开头引入trait**  
+   请求缓存
    +   请求缓存的原理是第一次请求的时候会根据当前请求的缓存标识把响应输出的内容缓存起来并且设置HTTP缓存（如果判断已经存在请求缓存的话会直接读取请求缓存并且设置HTTP缓存），当第二次访问相同的请求标识的时候，会自动读取HTTP缓存（也就是浏览器缓存）内容而不是真实的调用请求方法，也就是说请求缓存是HTTP缓存+响应（数据）缓存的合体
    +   如果你需求全局使用请求缓存的话，在应用配置中设置下面的两个配置参数
    
        ```php
        'request_cache'	=>	true,
        'request_cache_expire'	=>	600,
        ```
    +   请求缓存只支持GET请求，会进行缓存
    +   注意：当给当前URL地址增加参数后再次访问后会发现请求缓存已经无效了（因为全局请求缓存默认是根据URL地址缓存）
    +   如果需要设置个别请求的缓存参数，可以在路由规则中设置，例如博客首页设置缓存:
    
        ```php
        // 定义路由规则 并设置60秒的缓存
        Route::get('/','blog/Index/index',['cache'=>60]);
        ```
    +   **强烈推荐使用**
+   参数绑定
    +   使用参数绑定方式的代码更简洁
    
        ```php
        public function hello($name = '')
        {
            // 获取当前请求的name变量
            return $name;
        }
        ```
####  错误和异常处理
+   错误：错误是指在执行代码过程中发生的事件（无论是小事件还是严重事件都属于错误），它会干扰或中断代码的正常流程并有可能触发异常，虽然有些小的错误（例如警告错误）对程序流程影响不大，但却可能会是将来的一个隐患，如果不进行异常处理（即不对错误做出响应），程序的健壮性就会大打折扣，甚至无法保证正常运行，所以必须要进行异常处理以帮助恢复流程。换句话说，错误是一个事件，而异常是该事件创建的对象。        
+   注意，即使是中止执行也会执行appShutdown
+   默认框架会捕获所有的错误，包括PHP警告级别的错误，你可以在应用配置文件或者公共文件中（当然如果需要区分模块也可以在模块中单独设置）设置要报告的错误级别，例如：`error_reporting(E_ALL ^ E_NOTICE);`
+   记录错误日志，出于性能考虑，框架并不会实时写入日志信息，而是在程序执行完毕后通过Error::appShutdown()方法完成日志文件的统一写入
+   默认的report方法并不会记录HTTP异常日志（避免受一些攻击的影响写入大量日志）
+   由于错误机制的注册顺序问题，在入口文件中设置错误级别无效
+   手动捕获异常方式是使用try-catch，例如：

    ```php
    try {
        // 这里是主体代码
    } catch (ValidateException $e) {
        // 这是进行验证异常捕获
        return json($e->getError());
    } catch (\Exception $e) {
        // 这是进行异常捕获
        return json($e->getMessage());
    }
    ```
+   **部署模式**`('app_debug'=> false)`下一旦抛出了HttpException异常，可以定义单独的异常页面模板

    ```php
    'http_exception_template'    =>  [
        // 定义404错误的模板文件地址
        404 =>  APP_PATH . '404.html',
        // 还可以定义其它的HTTP status
        401 =>  APP_PATH . '401.html',
    ]
    ```
####  表单请求和验证   
+   设置状态码:`json($data,201);`等效`json($data)->code(201);` 
+   如果要获取当前响应对象实例的状态码的值，可以使用getCode方法
+   设置头信息,使用Response类的header设置响应的头信息

    ```php
    json($data)->code(201)->header(['Cache-control' => 'no-cache,must-revalidate']);
    ```
    > header方法支持两种方式设置，  
      如果传入数组，则表示批量设置，  
      如果传入两个参数，第一个参数表示头信息名，第二个参数表示头信息的值
####  重定向
+   可以使用redirect助手函数进行重定向:`return redirect('http://www.thinkphp.cn');`      
+   站内重定向:`redirect('/index/index/hello/name/thinkphp');` 
+   **记住请求地址** 
    +   在很多时候，我们重定向的时候需要记住当前请求地址（为了便于跳转回来），我们可以使用remember方法记住重定向之前的请求地址
    +   [记住请求地址官方文档](https://www.kancloud.cn/thinkphp/controller-in-detail/250875)
####  模板渲染
+   1、继承系统的控制器基类 ：`return $this->fetch();`   
+   2、没有继承系统的控制器基类 ：`return view();`   
+   2、系统变量及请求变量可以无需赋值而直接在模板中使用 ：输出`$_SESSION['user_id']`=> `{$Think.session.user_id}` 
####  行为和钩子
+   路由检测是一个行为、静态缓存是一个行为、用户权限检测也是行为