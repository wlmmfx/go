##  掌握ThinkPHP5.0数据库和模型
* 使用框架开发应用好处主要有两个
##  第五章：模型和对象
* 5.0的数据库抽象访问层（我们后面用Db类表示）和模型是一个整体，共同完成了ThinkPHP5.0的ORM（对象关系映射）
* Db负责的只是数据（表）访问，模型负责的是业务数据和业务逻辑。
* 模型层可以分的更细，把数据模型和逻辑模型，甚至服务模型分开，这个暂时就不在目前的讨论范畴了，只不过把模型层的职责和分工更细化
* 模型层可以分的更细，把数据模型和逻辑模型，甚至服务模型分开，这个暂时就不在目前的讨论范畴了，只不过把模型层的职责和分工更细化
* 通常每个数据表就对应了一个业务模型对象
* Db和模型最明显的一个区别就是**Db查询返回的数据类型为数组（对于一个没有业务逻辑的数据而言，数组已经足够），而模型的查询返回类型的是模型对象实例。**
* 由于Db类的数据操作并没有一个唯一对应的对象实例，也就无法封装业务方法
* 有些人虽然用了模型，但仍然在模型里面大量封装直接操作Db类的代码和方法，这也是一种伪模型设计，并不可取。
* 想要掌握模型，必须明白和理解下面几个原则：
    * 模型和数据库层的定位和职责不同；
    * 不要因为性能而放弃使用模型，那是得不偿失的；
    * 用面向对象的方式来使用和设计模型；
    * 模型的数据底层操作仍然是数据库抽象访问层，而且是自动的；
* 模型设计基于数据访问层之上，并作了更高层次的封装，实现了Db类本身不支持的功能，或者简化了原本使用Db类的复杂操作。    
* 从查询操作的角度来看，可以理解为Db类是**数据表的查询构造器**，而模型是**业务模型的查询构造器**，其实都属于查询构造器的范畴。    
* 在控制器中永远调用的是模型类,然后在模型类中封装业务逻辑方法和数据处理，完成业务操作。    
* 对控制器来说，模型就是一个业务逻辑接口，并且善于运用依赖注入机制来绑定模型对业务操作会带来极大的便利。 
* 模型定义有几个要素
    * 一个模型并不总是对应一个数据表（可能会有多个），虽然默认如此；
    * 模型名和数据表名也不是直接对应关系；
* 模型定义阶段要达成的目的
    * 定义数据表（默认就是模型类名）    
    * 定义数据表主键（默认会自动获取）    
    * 定义数据库连接（默认使用数据库配置）
* 下面的定义是不需要或者不支持的：
    * 数据表字段（不需要，会自动获取，并支持缓存机制）
    * 数据表前缀（不支持，模型不关心前缀）  
* 模型对应关系
* 1、默认：模型名（User）=》对应数据表（user）          
* 2、前缀：模型名（User）=》对应数据表（think_user）          
* 3、对应规则和上面的系统约定不符合：模型名（User）=》对应数据表（protected $table = 'user_info';）   
  > table属性定义的是完整数据表名，如果你希望定义不带前缀的数据表名，可以使用name属性来定义模型的名称。  
    如果你同时定义了这两个属性，那么table属性是优先的。
* 如果担心模型的名称和PHP关键字冲突，可以启用类后缀功能，只需要在应用配置文件中设置：`'class_suffix' => true,// 开启应用类库后缀`
* 关于模型的连接对象和查询对象，要清楚下面这些事实：
    * 模型可以单独设置数据库连接；
    * 模型的数据库连接是惰性的（因为连接本身就是惰性）；
    * 如果使用统一的数据库配置，模型使用的连接对象是相同的；
    * 模型使用的查询对象是独立的；
    * 模型可以使用自定义的查询对象；       
* 助手函数：`$user = model('User');`,实例化User模型类，并且model函数采用单例实现，多次调用不会重复实例化。 
* 助手函数并不支持模型的静态调用 
* 模型和Db操作的一大显性区别就是一个是对象操作和一个是数组操作
* 命令行生成
    * `php think make:model index/Blog` 生成index模块的Blog模型类文件
    * `php think make:model Blog` 生成的是common模块下面的Blog模型类
* 模型CURD操作
    * 创建操作用法小结
        * save（动态）
        * create（静态）
* 然后要注意几个注意事项：
    * 模型类可以直接调用Db类的所有方法；
    * 模型类和Db类的查询返回类型是完全不同的，即便是调用同一个方法查询；
    * 模型类封装的静态方法本质上还是调用的动态方法，只是为了方便不同的需求场景；
    * 模型对象的查询操作尽量使用静态方法调用；  
* 模型类不需要调用table方法来指定数据表名称，因为模型已经有自己的对应数据表规则，从这一点来说，模型的查询操作应该比Db类的查询操作用法简单^_^。          
* 模型可以直接调用Db类（确切的说是查询类）的方法，无论是静态还是动态调用，也就是说你可以把模型类当成Db类一样使用   
* 如果是数据集查询的话有两种情况，由于默认的数据集返回结果的类型是一个数组，因此无法调用toArray方法，必须先转成数据集对象然后再使用toArray方法，系统提供了一个collection助手函数实现数据集对象的转换，代码如下： 
  
    ```php
    $list = User::all();
    if($list) {
        $list = collection($list)->toArray();
    }
    ```        